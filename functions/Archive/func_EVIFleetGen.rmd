# Author: Schatz Energy Research Center
# Original Version: Jerome Carman
# Edits: Jerome Carman and/or Daug Saucedo and/or Andy Harris and/or Micah Wright
# Version: 2.0
# Date: March 7, 2019
# Description: Loads a data table containing EVIPro model data from NREL, applies user defined weights of fleet characteristics, and generates a fleet of vids
# Required Variables
#   evi: data table created using the loadEVIPro() function. Must have the following columns
#       "schedule_vmt_bin","power_public","power_work","power_home","preferred_loc","pev_type","day_of_week","vid"
#       Values in these columns MUST equal the values in the "name" column in the weights data tables listed below
#   fleet_size: integer specifying the size of the desired fleet
#   weights: list of data.tables with two columns ("name" and "weight") and rows containing names and associated decimals (with a sum of 1) that represent the fraction of fleet vehicles comprised of each variable in the name column.
#   use_mix: logical. Is the fleet built using pev weights or vmt weights? FALSE = use vmt weights. TRUE = use pev weights.
#   loc_class: character, either "urban" or "rural"
# Version History
#   1.1: JKC added the "rbind" approach to creating the weighted fleet, as opposed to the binary search appraoch. This creates a much closer
#         match to the desired fleet characteristics weights at the expense of not matching the fleet size exactly.
#   1.2: JKC added vmt_weights. Also added if statement to choose between "rbind" and binary search fleet creation approach depending on the
#         error between the resulting fleet size and the target fleet size.
#   1.3: JKC addressed issue with returning NA when looking for a vid in evi[] that matched all vehicle characteristics
#   1.4: JKC added comments, confirmed that use of vmt_weights applies to total daily vmt, not electric vmt.
#   1.5: JKC added use of temp_weights to accommodate new data set that varies by ambient temperature
#   2.0: MW - see GIT history for changes. One big change is we no longer allow specifying both pev_weights and vmt_weights. This is because
#         we were getting too many NA values, particularly in edge cases. We decided this was pushing the boundary of how flexible this dataset is.
#        NOTE: no longer has legacy support for older scripts
#   2.1: JKC added pev_type back in as NREL pushed for this. Dealing with NAs. Removed public_weights.

#########################################################

 Testing fleet gen function for resampling error
 Will step through with one set of variables

While this is primarily a data.table function load dplyr for testing

```{r}
options(scipen = 20)
library(dplyr)
library(readr)
library(data.table)
```

Global Variables

```{r}
fleet_size = 5000
mean_vmt = 40
bin_width = 10
loc_class = "urban"
```

Load evi data

```{r}
# evi_raw file
evi_raw_files <- dir("../../../../data/preprocessed/evi_raw", full.names = T)

# evi_raw <-read_rds(evi_raw_files[1]) # ~15 sec
```

Create weights

```{r}
## for creating weights
pev = c(0.25,0.25,0.25,0.25)
pref = c(0.8,0.2)
home = c(0.20,0.70,0.1)
work = c(0,1)

# playing with the suspected error
pev = pev * 100

fleet_weights <- create_fleet_weights(pev, # creates list of simple tables with preferences
                                      pref,
                                      home,
                                      work)

weights <- fleet_weights # var named weights below

#fleet_weights
```

# Different version required since this function calls data from a relative source
Load weight distribution function

```{r}
vmt_WeightDistGen <- function(mean_vmt, max_vmt, bin_width, loc_class, dow) {
  # Based on Barter et al 2015, Lin et al 2012, and Tamor et al 2015, we believe the gamma distribution to be a reasonable
  # approximation of the distribution of daily vmt. 
  
  # The gamma distribution is defined by 2 variables: shape (k) and scale (theta). The distribution mean is equal to 
  # shape * scale, and the variance is equal to shape * (scale)^2. Step one is to get these parameter values from the 
  # vmt distribution of the fleet
  
  # load the estimated gamma distribution parameters from est_VMT_parameters.Rmd 
  param <- fread("../../../../data/NHTS/gamma_est.csv")
  
  # extract rate estimate and use it to get the shape for the given mean
  rate.var <- param[urban == loc_class & day_of_week == dow, rate]
  shape.var <- rate.var * mean_vmt
  
  # Create a data table loaded with the vmt bins we want
  # This is right bin edge
  vmt_weights <- data.table(name = seq(bin_width, max_vmt, bin_width))
  
  # To assign weights, calculate the value of the CDF at each VMT bin. We will then subtract the CDF value from the 
  # previous bin to get the weight percentage for that bin.
  vmt_weights[, cdf := pgamma(name, shape = shape.var, rate = rate.var)]
  vmt_weights[, prev.cdf := c(0, cdf[.I - 1])]
  vmt_weights[, weight := cdf - prev.cdf]
  
  # Now trim the extraneous columns
  vmt_weights[,':=' (cdf = NULL, prev.cdf = NULL)]
  
  return(vmt_weights)
}
```


Start of function

```{r}
# evi_fleetGen <- function(evi_raw,
#                          fleet_size,
#                          weights,
#                          mean_vmt = 40,
#                          bin_width = 10,
#                          loc_class = "urban") {
  
  ################################################################################################################################
  #Create a data table of all potential permutations of fleet characteristics whose weights are user defined
  ################################################################################################################################

  # estimate vmt weights for the day of week
  # paste day of week onto name column, which aslo casts name to character 
  vmt_list <- sapply(c("weekday", "weekend"), simplify = FALSE, USE.NAMES = TRUE, function(x) {
    
  # names func_GenVmtWeights.R in functions folder
      vmt_wt <- vmt_WeightDistGen(mean_vmt, 
                                max_vmt = max(evi_raw$schedule_vmt, na.rm = TRUE), # will be different for each evi 
                                bin_width, 
                                loc_class, 
                                x) 
    
    vmt_wt[, name := paste(x, name, sep = "_")]
  })
  
  vmt_wt <- rbindlist(vmt_list)

  # add vmt weights to other weights
  weights <- c(weights, list("vmt_weights" = vmt_wt))
  
  # data table of all weights and groups combined
  all_weights <- rbindlist(weights)

  # Use expand.grid to create a data table of all permutations of groups to consider
  all_perms <- as.data.table(expand.grid(lapply(weights[c("pev_weights","pref_weights", "home_weights", "work_weights", "vmt_weights")], function(x) x[, name])))
  
  # specify column names
  colnames(all_perms) <- c("pev_type","preferred_loc", "power_home", "power_work", "schedule_vmt_bin")  
  
## I think all perms could be made before hand, although this is not the portion of the code that takes a long time
#all_perms
```

Functions above just get permutations into correct format  

```{r}
  #Calculate total weight for each permutation of groups
  # Iteratively join all_weights to all_perms, calculate the total weight for each permutation, then remove the joined weight column.
  setkey(all_weights,name) # sorting function (DT, key) for efficiently sorting data for other functions
  
  all_perms_names <- colnames(all_perms)
  all_perms[,stat_weight := 1] # mutate column / give column value 1
all_perms
``` 
  
Concerned about this function *TODO*
```{r}
  for(i in 1:length(all_perms_names)) {
    setkeyv(all_perms, all_perms_names[[i]])
    all_perms <- all_weights[all_perms]
    all_perms[, stat_weight := stat_weight * weight][, weight := NULL] # multiply weight by stat_weight and drop weight column
    setnames(all_perms, "name", all_perms_names[[i]])
  }
  
all_perms
#Factor values in each column. The corresponding factor numeric values correspond to the integer values used by NREL's
  #     file naming convention.
  # We don't factor schedule_vmt_bin (if created) as this will be re-cast back to integer
  all_perms[, power_work := factor(power_work, levels=c("WorkL1","WorkL2"))]
  all_perms[, power_home := factor(power_home, levels=c("HomeL1","HomeL2","HomeNone"))]
  all_perms[, preferred_loc := factor(preferred_loc, levels=c("PrefHome","PrefWork"))]
  all_perms[, pev_type := factor(pev_type, levels=c("PHEV20","PHEV50","BEV100","BEV250"))]

#all_perms$stat_weight %>% sum()
```

  ################################################################################################################################
  #Create a fleet data table where each row is the combined characteristics for each vehicle in the fleet.
  ################################################################################################################################

```{r}  
  #Create a fleet where each row is associated with a vehicle. Aggregated distribution matches weights - the number of
  # vehicles matching a particular description = fleet size * stat_weight; so if the combined weight for a vmt/public power/
  # work power/home power/preference/pev type combinatuion is 0.02 and the fleet size is 100, there will be 2 vehciles
  # in the fleet with that specific combination.
  # Fleet size may be slightly off for large fleets, and substantially off for small fleets when
  #     coupled with small stat_weight values because round(stat_weight*fleet_size,0) will return a lot of zeros.
## for all rows in all_perms that do not match 0 

  fleet <- all_perms[stat_weight!=0,
              do.call(rbind, 
                      replicate(round(stat_weight * fleet_size, 0), .SD, simplify=FALSE)),
              by = c("power_work", 
                     "power_home", 
                     "preferred_loc", 
                     "pev_type", 
                     "schedule_vmt_bin")]

# all_params will be the same for all scenarios, or for all runs. The weights will vary depending on the evi_raw file
fleet
all_perms$stat_weight %>% sum() # equals 2 and I think it should equal 1, equals 2 because fleet is for weekday and weekend #CHECK ON THIS
fleet$stat_weight %>% sum()

fleet %>% 
  filter(stat_weight == 0)
```


```{r}
  # partition schedule_vmt_bin to actual mileage bins and day of week indicators
  # recast schedule_vmt_bin to integer
  fleet[, ':=' (schedule_vmt_bin = as.integer(sub(".*\\_", "",schedule_vmt_bin)), # make new column of vmt 
                day_of_week = sub("\\_.*", "",  schedule_vmt_bin))] # new column weekday/weekend

  fleet[, day_of_week := factor(day_of_week, levels = c("weekday", "weekend"))] # change to factor

  fleet  
```

If the difference between the resulting fleet size from the above approach and the target fleet size is larger than 0.1%, use binary search fleet creation approach that ensures the correct fleet size at the expense of not obtaining the exact weights desired else apply small correction to obtain target fleet size if off by <= 0.1% of target fleet size

```{r}
  fleet_size_error <- sapply(c("weekday", "weekend"), simplify = TRUE, USE.NAMES = TRUE, function(i) {
    
    abs((nrow(fleet[day_of_week == i]) - fleet_size) / fleet_size)
    
  })

fleet %>% 
  group_by(day_of_week) %>% 
  count()
  
fleet_size_error
```


```{r}
  if( max(fleet_size_error) > 0.001 ) {
    print(paste0("Warning: fleet size error of ",as.character(fleet_size_error),". Updating..."))
    
    updated_fleet <- lapply(c("weekday", "weekend"), function(i){
      
      #If too small, add vehicles by randomly duplicating existing vehicles in fleet[]
      if(nrow(fleet[day_of_week == i]) < fleet_size ) {
        index <- fleet[day_of_week == i, sample(.I, fleet_size - .N)]
        fleet <- rbind(fleet[day_of_week == i], fleet[day_of_week == i][index])
        
        #If too large, randomly delete vehicles from fleet[]
      } else if(nrow(fleet[day_of_week == i]) > fleet_size ) {
        index <- fleet[day_of_week == i, sample(.I, .N - fleet_size)]
        fleet <- fleet[day_of_week == i][-index]
      }
    })
    # recombine weekend and weekday fleets
    fleet <- rbindlist(updated_fleet) 
}
```


```{r}
  ################################################################################################################################
  #Identify vid that matches each row of characteristics in the fleet data table. Merge in charge session data.
  ################################################################################################################################
  
  #Randomly pull and append a vid that has the characteristics specified in the fleet data table.
  # Identify the subset of vids in evi that are associated with each row in your fleet. Randomly pull one of these vids
  #     and associate it with each entry in your fleet. You now have a list of vids equal in size to your fleet.
  # Note that the number of unique vids may be less than the fleet size. This is because one vid can apply to more than
  #     one group characteristic permutation
  setkeyv(evi_raw,c("day_of_week","power_work","power_home","preferred_loc","pev_type","schedule_vmt_bin"))
  setkeyv(fleet,c("day_of_week","power_work","power_home","preferred_loc","pev_type","schedule_vmt_bin"))
  
  #Add VIDs to fleet[]
  fleet <- evi_raw[fleet,sample(unique_vid,1,replace=TRUE),by=.EACHI] #with replacement
  setnames(fleet,"V1","unique_vid")
  fleet
```
  
```{r}
  #Create a specific fleet ID number for each vehicle in the fleet. The unique_vid value can be chosen more than once, so cannot be
  # relied upon to be a truly unique identifier for each vehicle.
  fleet[,fleet_id:=1:.N]

#Check for and remove NA rows
  if(nrow(fleet[is.na(unique_vid)]) > 0 ) {
    print(paste0("NAs found. Removing ",as.character(nrow(fleet[is.na(unique_vid)]))," vehicles."))
    fleet <- fleet[!is.na(unique_vid),.SD]
  }
  
  #Create the final charging activity itinerary for the full fleet. This pulls all charging events for each unique_vid.
  # Note: when using vmt_weights, this only works if there are matching labels for evi_raw[,schedule_vmt_bin] and fleet[,schedule_vmt_bin]. This
  #     only makes sense if the bin widths used for the two data tables are equal.
  setkeyv(evi_raw,c("day_of_week","power_work","power_home","preferred_loc","pev_type","schedule_vmt_bin","unique_vid"))
  setkeyv(fleet,c("day_of_week","power_work","power_home","preferred_loc","pev_type","schedule_vmt_bin","unique_vid"))
  
  
  ############## Dont understand this line ################
  #Merge charge events with fleet
  fleet_activity <- evi_raw[fleet] # this is a data.table merge or subset
  
  #Generate fleet statistics to check with desired characteristics
  fleet_stats <- measureFleetWeights(fleet_activity)
  
  #Return results
  return(list("data" = fleet_activity, "stats" = fleet_stats))
  
#}


setkey(fleet_activity, vid)
fleet_activity
```

Run through some examples to see if I can recreate the low fleet errors

```{r}
evi_raw_files <- dir("../../../../data/preprocessed/evi_raw", full.names = T)

evi_raw <-read_rds(evi_raw_files[2]) # ~15 sec


## for creating weights
pev = c(0.25,0.25,0.25,0.25)
pref = c(0.8,0.2)
home = c(0.20,0.70,0.1)
work = c(0,1)

# The EVI-pro-lite function calls a set of preferences that it sends through the proceeding functions.
# EVI-pro-lite sends whole numbers that total 100 when the default values are perentages that sum to 1
# Running a test I was able to recreate the error when running the whole numbers but have not seen the error when running percentages
# I think thats the error for the fleet gen creation
# This error also makes the fleet size way too big which takes more time and might be the cause of the slowness error

pev = c(25,50,10,15)
pev/100
fleet_weights <- create_fleet_weights(pev, # creates list of simple tables with preferences
                                      pref,
                                      home,
                                      work)
fleet_weights
evi_fleetGen(fleet_size = 500,
             evi_raw = evi_raw, 
             weights = fleet_weights, 
             mean_vmt = 40,
             bin_width = 10,
             loc_class = "urban")
```

