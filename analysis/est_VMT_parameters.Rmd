---
title: "VMT distribution parameter estimates for urban and rural populations with NHTS"
author: "Micah Wright"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "..")
```

# Purpose

To estimate VMT distribution parameters for urban/rural populations on weekends/weekdays.

# Setup

Load the necessary packages and set ggplot theme.

```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(data.table)

theme_set(theme_classic())
```

Load the trip table from the NHTS dataset and the vmt by vehicle ID from NREL.

```{r}
trips <- fread("data/NHTS/trippub.csv")

chts_vmt <- fread("data/chts_dvmt.csv")
```

In preperation, what is the highest daily vmt from NREL? This will be used to truncate the VMT from NHTS later.

```{r}
vmt_max <- max(chts_vmt$dvmt)

vmt_max
```

Filter the trips to only include those that happend by car, truck, van, or SUV (TRPTRANS is one of 3:6), where a household vehicle was used (TRPHHVEH is 1), trip miles are greater than 0, and the respondent was the driver (DRVR_FLG is 1). The reason for the last condition is that if there are many individuals in a car, the trip is repeated across them, as shown below.

```{r}
knitr::kable(trips[HOUSEID == 30023735 ,.(PERSONID, TDTRPNUM,STRTTIME, ENDTIME, TRPMILES,TDAYDATE, TRAVDAY, VEHID, DRVR_FLG, DRIVER)])

trips <- trips[TRPTRANS %in% 3:6 & TRPHHVEH == 1 & TRPMILES > 0 & DRVR_FLG == 1]
```

Remove possibly erroneous observations. These are cases where travel day is not a weekend but is identified as a weekend trip, or vice-versa.

```{r}
trips <- trips[TDWKND == 1 & TRAVDAY %in% c(1, 7) | TDWKND == 2 & TRAVDAY %in% 2:6]
```

Calculate daily VMT. This assumes that trips are not repeated of the data are grouped by vehicle (VEHID), household (HOUSEID), date (TDAYDATE, in YYYYMM format), day of the week (TRAVDAY), and trip ID (TDCASEID). This also includes urban/rural indicator (URBRUR), which we will need later.

```{r}
vmt <- trips[, .(DAILYVMT= sum(TRPMILES)), 
             by = c("VEHID", "HOUSEID", "PERSONID", "TDAYDATE", "TRAVDAY", "URBRUR")]
```

There are some very large values for daily VMT. Look at those whose trip VMT > `r vmt_max`.

```{r}
knitr::kable(trips[TRPMILES > vmt_max, 
                   .(HOUSEID, PERSONID, TDTRPNUM, STRTTIME, ENDTIME, TRVLCMIN, TRPMILES, TRPTRANS, TRPMILES)])
```

It looks like most of these trips were longer than 12 hours (overlapped a day), or these are simply errors. How many vehicles actually went more than 1,000 miles in a day?

```{r}
ltrip <- vmt[, .(DAILYVMT, ge_vmt_max = "No")][DAILYVMT > vmt_max, ge_vmt_max := "Yes"][, .N, by = ge_vmt_max]
knitr::kable(ltrip)
```

There are `r ltrip[ge_vmt_max == "Yes", N]` vehicles that went over `r vmt_max` miles in a day. Remove any vehicles with daily vmt greater than `r vmt_max` miles for now.

```{r}
vmt <- vmt[DAILYVMT < vmt_max]
```

Create a weekend/weekday column, and give urban/rural meaningful names.

```{r}
vmt[, ':=' (TDWKND = factor(ifelse(TRAVDAY %in% c(1,7), "weekend", "weekday")),
            URBRUR =  factor(URBRUR, labels = c("urban", "rural")))]
```

Inspect the mean VMT for each weekend/weekday and urban/rural scenario.

```{r}
knitr::kable(vmt[, .(mean_vmt = mean(DAILYVMT),
                     max_vmt = max(DAILYVMT)),
                 by = c("TDWKND", "URBRUR")])
```

Create a list of subsets of the data by urban/rural and weekday/weekend and estimate the gamma distribution parameters.

```{r}
dt_list <- split(vmt, by = c("TDWKND", "URBRUR")) 

est_list <- lapply(dt_list, function(x) MASS::fitdistr(x$DAILYVMT, "gamma", lower = c(0,0)))  
```

Look at the shape of distributions generated using these parameters.

```{r}
palette <- colorRampPalette(colors=c("navy", "steelblue1"))
cols <- palette(length(est_list))

curve(dgamma(x,
             shape = est_list$weekday.urban[["estimate"]][["shape"]], 
             rate =  est_list$weekday.urban[["estimate"]][["rate"]]), 
      from = 0, 
      to = 200,
      n = 1000, 
      type = "l",
      col = "navy",
      ylab = "density",
      xlab = "vmt")

for(i in 2:length(est_list)) {
  curve(dgamma(x,
               shape = est_list[[i]][["estimate"]][["shape"]], 
               rate =  est_list[[i]][["estimate"]][["rate"]]), 
        from = 0, 
        to = 200,
        n = 1000, 
        type = "l",
        col = cols[i],
        ylab = NULL,
        xlab = NULL,
        add = TRUE)
}

legend("topright",
       col = cols,
       legend = names(est_list),
       lty = 1)
```

Inspect what the ouput might be like with different means and a rate matching the weekday-urban scenario.

```{r}
opts <- seq(20, 50, 5)

get_gam <- function(x, rate) {
  
  shape <- x * rate 
  
  return(list("shape" = shape, "rate" = rate))
}

test <- lapply(opts, function(i) get_gam(i, est_list$weekday.urban[["estimate"]][["rate"]]))

names(test) <- as.character(opts)

curve(dgamma(x,
             shape = test[[1]]$shape, 
             rate =  test[[1]]$rate), 
      from = 0, 
      to = 200,
      n = 1000, 
      type = "l",
      col = "navy",
      ylab = "density",
      xlab = "vmt")

palette <- colorRampPalette(colors=c("navy", "steelblue1"))
cols <- palette(length(opts))

for(i in 2:length(test)) {
  curve(dgamma(x,
             shape = test[[i]]$shape, 
             rate =  test[[i]]$rate), 
      from = 0, 
      to = 200,
      n = 1000, 
      type = "l",
      ylab = NULL,
      xlab = NULL,
      col = cols[i],
      add = TRUE)
}

legend("topright",
       col = cols,
       legend = opts,
       lty = 1)
```

Convert the output to a data frame, look at it, and save it.

```{r}
est_list <- lapply(est_list, function(x) as.data.table(broom::tidy(x)))

est_dt <- rbindlist(est_list, idcol = TRUE)

est_dt[, ':=' (day_of_week = sub("\\..*", "", .id),
               urban = sub(".*\\.", "", .id))]

est_dt <- dcast(est_dt, day_of_week + urban ~ term, value.var = "estimate")

knitr::kable(est_dt)

fwrite(est_dt, "data/NHTS/gamma_est.csv")
```
