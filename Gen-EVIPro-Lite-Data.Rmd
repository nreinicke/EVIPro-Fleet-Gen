---
title: "EVI-Pro Load Profiles for Version 2 of EVI-Pro Lite Webtool"
subtitle: "Document all steps used to generate final data set delivered to NREL"
author: "Jerome Carman, Senior Research Engineer, Schatz Energy Research Center"
date: "5/4/2020"
output: html_document
---

#Setup
```{r}
# Set working directory
setwd("/media/spin/sein-evi/source/NREL-Model-Project/")

# Source libraries and functions
library(future.apply)
library(ggplot2)
library(data.table)
library(magrittr)
library(foreach)
library(doFuture)
library(doParallel)
library(scales)
source("./functions/func_preprocess.R") # Does some pre-processing of data sent by NREL and saves as .rds files
source("functions/func_openEVI.R") # 
source("functions/func_randVector.R") # 
source("functions/loadProfiles.R") # 
source("functions/loadRawData.R")
source("functions/func_joinOn.R") #Fast join function
source("functions/func_strEval.R") #String evulation function
source("functions/func_pp.R") #Alias for paste
source("functions/func_LoadEVIPro.R") #loads EVIPro data and stores in a single data table
source("functions/func_EVIFleetGen.R") #Generates a fleet of EVIPro vids
source("functions/func_calcBaseEVILoad.R") #Pre-calculates load profile for all unique_vid in evi_raw
source("functions/func_measureFleetWeights.R") #Creates statistics of generated fleet
source("functions/func_LoadFleetWeights.R") #Loads .csv file where fleet characteristic weights are stored
source("functions/func_GenVmtWeights.R") #Generates vmt distribution for fleet generation
source("functions/func_CreateFleetWeights.R") #Creates fleet weights from values hard coded in this function.
source("functions/func_GenFleetProfiles.R") #Creates 48-hour load profile for the resulting fleet

# Setup futures parallel processing
options(future.fork.enable = T)
options(future.globals.maxSize = 25000 * 1024^2) # Set max RAM allowed for global variables. XMB * 1024^2

# Define function to retrieve names from list
getNames <- function(vec, option) {
	# subset list to match given option	 
	out <-	lapply(vec, function(x) {
		x[all(x == unlist(option))]
	})
	# filter out zero length lists
	return(names(Filter(length, out)))
}
```

#Generate DVMT distributions
Only need to do this once
```{r}
# "../../data/NHTS/gamma_est.csv" generated with "./analysis/est_VMT_parameters.Rmd"
```

#Generate .rds files of EVI-Pro charge session data and time series load profiles
Only need to do this once. This takes an hour or so and generates about 20GB total in files.
```{r}
# Set number of CPU cores to make available
plan(multicore, workers = 12)

#Generate list of temperatures that we have for EVI-Pro data that we want to process
temp_vec <- seq(-20,40, 5)
temp_vec <- paste0(temp_vec, "C")

# Sedans: nothing returned. Results saved in specified output directories
preprocess_NREL_data(temp_list = temp_vec,
																					inputdir_evipro = "../../data/sessions_all_ambient_temps/",
																					inputdir_chts = "../../data/chts_dvmt.csv",
																					outputdir_eviraw = "../../data/preprocessed/evi_raw/",
																					outputdir_loadprofile = "../../data/preprocessed/load_profile/",
																					vmt_bin_size = 10,
																					loadprofile_timestep = 0.25)

# SUVs: nothing returned. Results saved in specified output directories
preprocess_NREL_data(temp_list = temp_vec,
																					inputdir_evipro = "../../data/sessions_all_ambient_temps_suv/",
																					inputdir_chts = "../../data/chts_dvmt.csv",
																					outputdir_eviraw = "../../data/preprocessed/evi_raw_suv/",
																					outputdir_loadprofile = "../../data/preprocessed/load_profile_suv/",
																					vmt_bin_size = 10,
																					loadprofile_timestep = 0.25)
```

#Generate data to be delivered to NREL
```{r}
# output folder
out_folder <- "../../output/EVIPro-Lite/20200506/"
if(!dir.exists(out_folder)) {
  dir.create(out_folder)
  dir.create(paste0(out_folder,"runlogs/"))
}

# Initialize log file to catch debugging output
log_file <<- file(paste0(out_folder,"runlogs/EVIProLite_RunLog_", format(Sys.time(), "%d-%b-%Y_%H-%M"), ".log"), open = 'a')

# Load Fleet Characteristic Vectors ------------------------------------------------------------

# count of total number of PEVs
fleet_size_vec <- list(1000,
																							10000,
																							50000) 

# average daily miles traveled per vehicle
mean_dvmt_vec <- c(25,
																			35,
																			45) 

# Temperature
temp_vec <- c("-20C", # celsius
														"-10C",
														"0C",
														"10C",
														"20C",
														"30C",
														"40C"
)

# PEV Type (confirm the meaning of the labels) (def named wrong)
pev_type_vec <- list("BEV" = c(.10, .15, .25, .50), # BEV Dominant
																					"PHEV" = c(.25, .50, .10, .15), # PHEV Dominant
																					"EQUAL" = c(.15, .35, .15, .35)) # PHEV/BEV Equal share

# adding the vehicle class variable
veh_class_vec <- list("Sedan" = c(0.8, 0.2), # sedan dominant
																						"Equal" = c(0.5, 0.5), # equal distribution
																						"SUV" = c(0.2, 0.8)) # suv dominant

# Geography
loc_class_vec <- list("urban")

# Home Access and Power 																# L1, L2, % without access to home power 
home_power_vec <- list("HA100_MostL1" = c(0.80, 0.20, 0), #100% access to home power, 80% of those L1
																							"HA100_MostL2" = c(0.20, 0.80, 0), #100% access to home power, 80% of those L2
																							"HA100_Equal" = c(0.5, 0.5, 0), #100% access to home power, 50% of those L2
																							"HA75_MostL1" = c(0.6, 0.15, 0.25), #75% access to home power, 80% of those L1
																							"HA75_MostL2" = c(0.15, 0.6, 0.25), #75% access to home power, 80% of those L2
																							"HA75_Equal" = c(0.375, 0.375, 0.25), #75% access to home power, 50% of those L2
																							"HA50_MostL1" = c(0.4, 0.1, 0.5), #50% access to home power, 80% of those L1
																							"HA50_MostL2" = c(0.1, 0.4, 0.5), #50% access to home power, 80% of those L2
																							"HA50_Equal" = c(0.25, 0.25, 0.5)) #50% access to home power, 50% of those L2

# Work power
work_power_vec <- list(
	"MostL2" = c(0.2, 0.8),
	"Equal" = c(0.5, 0.5),
	"MostL1" = c(0.8, 0.2)
)

# Home work preference
pref_vec <- list(
	"Home100" = c(1.0, 0.0),
	"Home80" = c(0.8, 0.2),
	"Home60" = c(0.6, 0.4)
)

# Set Data ----------------------------------------------------------------

# Create df of all vector options, excluding temperature. A separate results file is generated for each temperature.
all_options <- data.table(expand.grid(numveh = fleet_size_vec,
																																						pev = pev_type_vec,
																																						dvmt = mean_dvmt_vec, 
																																						home = home_power_vec, 
																																						work = work_power_vec, 
																																						loc = loc_class_vec, 
																																						vclass = veh_class_vec, 
																																						pref = pref_vec))

# add ID column to split on
all_options[, ID := seq(1:nrow(all_options))]

# Set number of workers (cores) globally
plan(multicore, workers = 6)

# Run loop ----------------------------------------------------------------

# run loop for each temp vec
lapply(temp_vec, function(temp) {
	
	# time testing
	start <- Sys.time()
	
	# split all options list
	all_options_list <- split(all_options, all_options$ID)
	
	# Load raw charging session and load profile .rds files
	raw_data <- loadRawData(temp)
	
	# Create load profiles by looping over all permutations of options
	fleet_load <- future_lapply(all_options_list, function(options_list) {
		
		# Create fleet
		fleet_sub <-
			openEVI(
				evi_raw = raw_data[[1]],
				fleet = unlist(options_list$numveh),
				pev = unlist(options_list$pev),
				dvmt = options_list$dvmt,
				pref = unlist(options_list$pref),
				home = unlist(options_list$home),
				work = unlist(options_list$work),
				loc = options_list$loc,
				veh_class = unlist(options_list$vclass))
		
		# Debug to catch when NAs are generated
		tryCatch(na.fail(fleet_sub),error = function(x) cat(paste0("\nTemp ",temp,", option ID ",as.character(options_list$ID)," generated NAs in fleet_sub."),file=log_file, append=T))
		
		# Create load profile of fleet
		load_to_bind <- get_fleet_profiles(fleet_sub,
																																					unlist(options_list$numveh),
																																					raw_data[[2]])
		
		# Debug to catch when NAs are generated
		tryCatch(na.fail(load_to_bind),error = function(x) cat(paste0("\nTemp ",temp,", option ID ",as.character(options_list$ID)," generated NAs in load_to_bind - location 1"),file=log_file, append=T))
		
		# Create Names ----------------------------------------------------------------------- 
		
		load_to_bind[, ':=' (# loc_class = options_list$loc[[1]],
			temp_c = temp,
			fleet_size = options_list$numveh[[1]],
			mean_dvmt = options_list$dvmt,
			pev_dist = getNames(pev_type_vec, options_list$pev),
			pref_dist = getNames(pref_vec, options_list$pref),
			# split home access vector, select first element, home access
			home_access_dist = regmatches(getNames(home_power_vec, options_list$home),
																												regexpr("_", getNames(home_power_vec, options_list$home)),
																												invert = T)[[1]][1],
			# split home access vector, select second element, home power distribution 
			home_power_dist = regmatches(getNames(home_power_vec, options_list$home),
																																regexpr("_", getNames(home_power_vec, options_list$home)),
																																invert = T)[[1]][2],
			work_power_dist = getNames(work_power_vec, options_list$work),
			class_dist = getNames(veh_class_vec, options_list$vclass)
		)] # end add naming columns
		
		# Debug to catch when NAs are generated
		tryCatch(na.fail(load_to_bind),error = function(x) cat(paste0("\nTemp ",temp,", option ID ",as.character(options_list$ID)," generated NAs in load_to_bind - location 2"),file=log_file, append=T))
		

		# Summarize Data ----------------------------------------------------------
		
		# summarize data based on distinct options
		load_to_bind[time_of_day > 24,time_of_day := time_of_day - 24]
		load_to_bind <- load_to_bind[, .(kw = sum(avg_kw)),
																															by = c(# "loc_class",
																																"temp_c",
																																"fleet_size",
																																"mean_dvmt",
																																"pev_dist",
																																"pref_dist",
																																"home_access_dist",
																																"home_power_dist",
																																"work_power_dist",
																																"class_dist",
																																"day_of_week",
																																"pev_type", 
																																"dest_type", 
																																"dest_chg_level",
																																"class_type",
																																"time_of_day"
																																)]
		
		# Debug to catch when NAs are generated
		tryCatch(na.fail(load_to_bind),error = function(x) cat(paste0("\nTemp ",temp,", option ID ",as.character(options_list$ID)," generated NAs in load_to_bind - location 3"),file=log_file, append=T))
		
		setkey(load_to_bind,
									#loc_class,
									temp_c,
									fleet_size,
									mean_dvmt,
									pev_dist,
									pref_dist,
									home_access_dist,
									home_power_dist,
									work_power_dist,
									day_of_week,
									pev_type,
									dest_type,
									dest_chg_level,
									class_type,
									time_of_day)
		

		return(load_to_bind)
	}) # end of future apply
	
	# bind results together
	fleet_load <- rbindlist(fleet_load)
	
	# remove large objects
	#gc(rm(raw_data))
	
	# Change data types --------------------------------------------------------------------------------- 
	#change temp, fleet size, dvmt to integer
	fleet_load[, temp_c := as.integer(gsub("C", "", temp_c))]
	
	# convert other columns to integer
	fleet_load[, fleet_size := as.integer(fleet_size)]
	fleet_load[, mean_dvmt := as.integer(mean_dvmt)]
	
	
	# Save output ----------------------------------------------------------------------------------------
	#Write fleet_load out to disk
	fwrite(fleet_load,
								file = paste0(out_folder,
																						gsub("-", "", Sys.Date()), "_", # date the run
																						temp,
																						".csv"))
	
	print(Sys.time() - start)
	# gc(rm(raw_data) full = T)
	
}) # end of temp vec lapply

# This function restarts the R session and can be used to clear memory
# Cannot be used within any type of looping function
#.rs.restartR()
```

#Review and check results
```{r}
file_paths <- dir(out_folder, pattern = ".csv", full.names = T)

# Create lazy function to subset results and graph load
#			*lazy* refers to the fact that this is a wrapper for a workflow rather than a more generalizable function.
graphFunc <- function(d, f_size, dvmt) {
	sub_check <- d[fleet_size == f_size & # largest fleet size
	mean_dvmt == dvmt &
	pev_dist == "BEV" &
	pref_dist == "Home60" &
	home_access_dist == "HA50" &
	home_power_dist == "Equal" &
	work_power_dist == "MostL2" &
	class_dist == "Sedan",
	.(sum_kw = sum(kw)),
	by = c("dest_type",
	"dest_chg_level",
	"time_of_day",
	"day_of_week")]
	
	# round values for ave kw to make graph more readable
	# sub_check$sum_kw <- round(sub_check$sum_kw, digits = 2)
	
	# Show kw by destination, charge type, and vehicle class throughout the day
	plotResult <- ggplot(data = sub_check, aes(x = time_of_day, y = sum_kw)) +
	geom_area(aes(fill = dest_chg_level)) +
	facet_grid(day_of_week ~ dest_type) +
	scale_y_continuous(label = comma) +
	labs(
	fill = "Destination Charge Level",
	y = "Sum kw",
	x = "Time of Day",
	subtitle = paste("Fleet Size of ", f_size, "and mean daily VMT of", dvmt,"\npev_dist=BEV, pref_dist=Home60,\nhome_access_dist=HA50, home_power_dist=Equal,\nwork_power_dist=MostL2, class_dist=Sedan")
	) +
	theme(legend.position = "bottom", text = element_text(size = 16))
	
	return(plotResult)
}

# Loop through each data set, check for NAs and
# plot L2 charging only to check for any issues associated with previously observed discontinuities
plan(multicore, workers=7)
plot_results <- future_lapply(file_paths, function(i) {
	d_output <- fread(i)
	
	# Uniform dist to randomly pick fleet size and dvmt to spot check
	pick_fleet_size <- round(runif(1,1,3))
	pick_dvmt <- round(runif(1,1,3))
	
	# Check for NAs
	tryCatch(na.fail(d_output),error = function(x) cat(paste0("\nNAs found in ",i,", for fleet size ",as.character(fleet_size_vec[[pick_fleet_size]])," and DVMT ",as.character(mean_dvmt_vec[[pick_dvmt]])),file=log_file, append=T))
	
	# Generate plot
	result <- graphFunc(d_output,
																					f_size = fleet_size_vec[[pick_fleet_size]],
																					dvmt = mean_dvmt_vec[[pick_dvmt]])
	
	return(result)
})

plot_results

```